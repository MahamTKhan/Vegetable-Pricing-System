# -*- coding: utf-8 -*-
"""Sindh Vegetables Price Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d3F1pRDxA3O9L2q-qWidWcyjUr30Y8ZL

# Importing Dependencies
"""

!pip install pmdarima

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import datetime
import math
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.graphics.tsaplots import plot_pacf
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from keras.preprocessing.sequence import TimeseriesGenerator
from keras.models import Sequential
from keras.layers import Dense, LSTM

import warnings
warnings.filterwarnings("ignore")

"""# Data Exploration"""

df = pd.DataFrame(pd.read_excel("/content/Sindh Vegetable Prices.xlsx", index_col="Date", parse_dates= True))
print("Shape of Data: ", df.shape)
df.head()

df.columns

df.info()

df.describe()

"""# Detecting Outliers"""

df.boxplot()
plt.ylabel("Price in (RS)")
plt.xticks(rotation=45)
plt.title("Box Plot For Detecting Outliers")
plt.show()

"""## Handling Outliers"""

# findoutliers will list the number of outliers in each column and handle them by replacing the outliers with the
# lower or upper limit of the quantile range

def findoutliers(column):
    outliers=[]
    Q1= column.quantile(.25)
    Q3= column.quantile(.75)
    IQR= Q3-Q1
    lower_limit= Q1-(1.5*IQR)
    upper_limit= Q3+(1.5*IQR)

    for i in range (len(column)):
        if (column[i]>upper_limit):
            outliers.append(column[i])
            column[i]=upper_limit

        elif (column[i]<lower_limit):
            outliers.append(column[i])
            column[i]=lower_limit

    return outliers

for i in df.columns:
    print("Number of outliers in "+i+" are:", len(findoutliers(df[i])))

"""# Detecting Data Skewness"""

# Skewed data---> null values will be replaced with median/mode

for i in df.columns:
    skewness = df[i].skew()

    if (skewness==0):
        print(i+" is Skewed with a value of= "+skewness)
    elif (skewness<0):
        print(i+" is Negatively Skewed with a value of= "+str(skewness))
    else:
        print(i+" is Positively Skewed with a value of= "+str(skewness))

"""# Detecting and Handling Null Values"""

# Check for Null Values
df.isnull().sum()

# Replacing null values in each column with the median value
for i in df.columns:
    df[i] = df[i].fillna(df[i].median())

"""# Detecting Stationarity of Data"""

# The data needs to be stationary to apply Time Series models
def adfuller_test(datacol):
    df_test= adfuller(datacol, autolag="AIC")

    if (df_test[1]<=0.05):
        return "Stationary Data"
    else:
        return "Non-Stationary Data"

for i in df.columns:
    res= adfuller_test(df[i])
    print(i+": "+res)

"""# Data Visualization

### Price Variance of Vegetables Over Time
"""

# Scatter Plot
plt.figure(figsize=(10,6))

for col in df.columns:
    sns.relplot(data=df,x=df.index,y=col)
    plt.xticks(rotation=45)
    plt.ylabel("Price in (RS)")
    plt.title("Price Variance of "+col+ " Over Time")
    plt.show()

# Line Plot
for col in df.columns:
    plt.figure(figsize=(10,6))

    # plot the price variance over time
    sns.lineplot(x= df.index, y=df[col])
    plt.xlabel('Date')
    plt.ylabel('Price in (RS)')
    plt.title('Price Variance of '+col)
    plt.xticks(rotation=45)
    plt.show()

"""### Vegetables Sold Count Against Prices"""

for col in df.columns:
    plt.figure(figsize=(14,8))
    df[col].value_counts().plot(kind='bar')
    plt.title(col)
    plt.xlabel('Price in (RS)')
    plt.ylabel('Count')
    plt.xticks(rotation=90)
    plt.show()

plt.figure(figsize=(10,6))

for col in df.columns:
    plt.hist(df[col])
    plt.xlabel('Value')
    plt.ylabel('Frequency')
    plt.title(col)
    plt.show()

"""### Comparing Price Distribution"""

plt.figure(figsize=(10,6))
sns.violinplot(data=df)
plt.title('Price Variance of Vegetables Over Time')
plt.ylabel("Price in (RS)")
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(10,6))
sns.set(style="whitegrid")
ax = sns.boxenplot(data=df)
ax.set_xticklabels(ax.get_xticklabels(), rotation=45)
ax.set_xlabel("Vegetables")
ax.set_ylabel("Price (in Rs.)")
ax.set_title("Comparing Price Distributions of all Vegetables")
plt.show()

sns.pairplot(df)
plt.show()

"""### Price Correlation Between Vegetables"""

plt.figure(figsize=(10,6))
plt.plot(df.index, df["Garlic"], label="Garlic")
plt.plot(df.index, df["Ginger"], label="Ginger")
plt.legend()
plt.xlabel("Date")
plt.ylabel("Price (in Rs.)")
plt.xticks(rotation=45)
plt.title("Line Chart of Garlic and Ginger Prices over Time")
plt.show()

plt.figure(figsize=(10,6))
plt.plot(df.index, df["Potato"], label="Potato")
plt.plot(df.index, df["Onion"], label="Onion")
plt.legend()
plt.xlabel("Date")
plt.ylabel("Price (in Rs.)")
plt.xticks(rotation=45)
plt.title("Line Chart of Potato and Onion Prices over Time")
plt.show()

plt.figure(figsize=(10,6))
plt.plot(df.index, df["Carrot"], label="Carrot")
plt.plot(df.index, df["Peas"], label="Peas")
plt.legend()
plt.xlabel("Date")
plt.ylabel("Price (in Rs.)")
plt.xticks(rotation=45)
plt.title("Line Chart of Carrot and Peas Prices over Time")
plt.show()

plt.figure(figsize=(10,6))
plt.plot(df.index, df["Tomato"], label="Tomato")
plt.plot(df.index, df["Green Chilli"], label="Green Chilli")
plt.legend()
plt.xlabel("Date")
plt.ylabel("Price (in Rs.)")
plt.xticks(rotation=45)
plt.title("Line Chart of Tomato and Green Chilli Prices over Time")
plt.show()

plt.figure(figsize=(16,10))
corr = df.corr()
sns.heatmap(corr,annot=True)
plt.title("Price Correlation Between Vegetables")
plt.show()

"""# TRAINING USING SARIMA MODEL"""

# Finding the order for the model
# for i in df.columns:
#     stepwise_fit= auto_arima(df[i], seasonal=True, m=12, suppress_warnings=True, error_action='ignore', trace=True)
#     print(i, "\n", stepwise_fit.summary())

"""### Predicting Potato Prices"""

# Select only the first column for modeling
data = df.iloc[:, 0]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.9)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(1,1,1), seasonal_order=(2,1,4,24))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_potato = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_potato = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_potato, y_pred_potato))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_potato, y_pred_potato)))

# Plot the predicted and actual values
plt.plot(date, y_pred_potato, label="Predictions")
plt.plot(date, y_test_potato, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Potato")
plt.legend()
plt.show()

"""### Predicting Onion Prices"""

# Select only the second column for modeling
data = df.iloc[:, 1]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data,date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(0,1,1), seasonal_order=(0,1,1,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_onion = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_onion = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_onion, y_pred_onion))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_onion, y_pred_onion)))

# Plot the predicted and actual values
plt.plot(date, y_pred_onion, label="Predictions")
plt.plot(date, y_test_onion, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Onion")
plt.legend()
plt.show()

"""### Predicting Peas Prices"""

# Select only the second column for modeling
data = df.iloc[:, 2]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(0,1,4), seasonal_order=(0,1,4,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_peas = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_peas = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_peas, y_pred_peas))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_peas, y_pred_peas)))

# Plot the predicted and actual values
plt.plot(date, y_pred_peas, label="Predictions")
plt.plot(date, y_test_peas, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Peas")
plt.legend()
plt.show()

"""### Predicting Tomato Prices"""

# Select only the second column for modeling
data = df.iloc[:, 3]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(4,1,5), seasonal_order=(2,0,0,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_tomato = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_tomato = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_tomato, y_pred_tomato))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_tomato, y_pred_tomato)))

# Plot the predicted and actual values
plt.plot(date, y_pred_tomato, label="Predictions")
plt.plot(date, y_test_tomato, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Tomato")
plt.legend()
plt.show()

"""### Predicting Carrot Prices"""

# Select only the second column for modeling
data = df.iloc[:, 4]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(0,1,2), seasonal_order=(0,1,2,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_carrot = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_carrot = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_carrot, y_pred_carrot))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_carrot, y_pred_carrot)))

# Plot the predicted and actual values
plt.plot(date, y_pred_carrot, label="Predictions")
plt.plot(date, y_test_carrot, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Carrot")
plt.legend()
plt.show()

"""### Predicting Garlic Prices"""

# Select only the garlic column for modeling
data = df.iloc[:, 5]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(0,1,1), seasonal_order=(0,1,1,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_garlic = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_garlic = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_garlic, y_pred_garlic))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_garlic, y_pred_garlic)))

# Plot the predicted and actual values
plt.plot(date, y_pred_garlic, label="Predictions")
plt.plot(date, y_test_garlic, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Garlic")
plt.legend()
plt.show()

"""### Predicting Ginger Prices"""

# Select only the ginger column for modeling
data = df.iloc[:, 6]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(3,0,0), seasonal_order=(0,0,0,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_ginger = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_ginger = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_ginger, y_pred_ginger))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_ginger, y_pred_ginger)))

# Plot the predicted and actual values
plt.plot(date, y_pred_ginger, label="Predictions")
plt.plot(date, y_test_ginger, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Ginger")
plt.legend()
plt.show()

"""### Predicting Green Chili Prices"""

# Select only the green chili column for modeling
data = df.iloc[:, 7]

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(np.array(data).reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data, date = scaled_data[:train_size], scaled_data[train_size:], data.index[train_size:]

# Fit the SARIMA model
model = SARIMAX(train_data, order=(2,1,2), seasonal_order=(2,1,2,12))
model_fit = model.fit()

# Make predictions on the test data
predictions = model_fit.forecast(steps=len(test_data))

# Rescale the predicted and actual prices to their original range
y_pred_chili = scaler.inverse_transform(predictions.reshape(-1, 1))
y_test_chili = scaler.inverse_transform(test_data.reshape(-1, 1))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_chili, y_pred_chili))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_chili, y_pred_chili)))

# Plot the predicted and actual values
plt.plot(date, y_pred_chili, label="Predictions")
plt.plot(date, y_test_chili, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Green Chili")
plt.legend()
plt.show()



# (2,1,2)(0,0,0)

train,test= df["Potato"].iloc[:-50],df["Potato"].iloc[-50:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(2,1,2), seasonal_order=(2,1,2,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Potato")
plt.legend()
plt.show()

"""MAHAM TRYING"""

train, test = df["Onion"].iloc[:-15], df["Onion"].iloc[-15:]

sarima_model = SARIMAX(train, order=(0, 1, 1), seasonal_order=(1, 0, 0, 12))
model_fit = sarima_model.fit()

print(model_fit.summary())


predictions = model_fit.forecast(steps=len(test))

print("MAE: ", mean_absolute_error(test, predictions))

print("RMSE: ", math.sqrt(mean_squared_error(test, predictions)))

# (0,1,1)(1,0,0)

train,test= df["Onion"].iloc[:-15],df["Onion"].iloc[-15:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(0,1,1), seasonal_order=(1,0,0,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Onion")
plt.legend()
plt.show()

# (0,1,4)(0,0,0)

train,test= df["Peas"].iloc[:-10],df["Peas"].iloc[-10:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(0,1,4), seasonal_order=(0,1,4,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Peas")
plt.legend()
plt.show()

# (4,1,5)(2,0,0)

train,test= df["Tomato"].iloc[:-10],df["Tomato"].iloc[-10:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(0,1,0), seasonal_order=(0,1,0,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Tomato")
plt.legend()
plt.show()

# (0,1,2)(0,0,0)

train,test= df["Carrot"].iloc[:-15],df["Carrot"].iloc[-15:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(1,1,1), seasonal_order=(1,0,1,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Carrot")
plt.legend()
plt.show()

# (0,1,1)(1,0,0)

train,test= df["Garlic"].iloc[:-15],df["Garlic"].iloc[-15:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(0,1,1), seasonal_order=(1,0,0,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Garlic")
plt.legend()
plt.show()

train,test= df["Ginger"].iloc[:-10],df["Ginger"].iloc[-10:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(3,0,0), seasonal_order=(3,0,0,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Ginger")
plt.legend()
plt.show()

# (2,1,2)(0,0,0)

train,test= df["Green Chilli"].iloc[:-10],df["Green Chilli"].iloc[-10:]

# Fit the SARIMA model
sarima_model = SARIMAX(train, order=(1,1,0), seasonal_order=(2,2,2,12))
model_fit = sarima_model.fit()

# Generate predictions for the testing set
predictions = model_fit.forecast(steps=len(test))

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(test, predictions))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(test, predictions)))

# Plot the predicted and actual values
plt.plot(test.index, predictions, label="Predictions")
plt.plot(test.index, test, label="Actual")
plt.xlabel("Date")
plt.ylabel("Price")
plt.xticks(rotation=45)
plt.title("Comparing Predicted and Actual Prices of Green Chilli")
plt.legend()
plt.show()

"""# TRAINING USING LSTM MODEL"""

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled = scaler.fit_transform(df.values)

train_size = int(len(scaled) * 0.8)
train, test = scaled[:train_size], scaled[train_size:]

time_steps = 60
n_features = 8

# Define the input sequences and corresponding labels
def create_sequences(dataset, time_steps):
    X, y = [], []
    for i in range(len(dataset)-time_steps):
        X.append(dataset[i:i+time_steps])
        y.append(dataset[i+time_steps])
    return np.array(X), np.array(y)

X_train, y_train = create_sequences(train, time_steps)
X_test, y_test = create_sequences(test, time_steps)

X_train = np.reshape(X_train, (X_train.shape[0], time_steps, n_features))
X_test = np.reshape(X_test, (X_test.shape[0], time_steps, n_features))

model = Sequential()
model.add(LSTM(units=128, return_sequences=True, input_shape=(time_steps, n_features)))
model.add(LSTM(units=64, return_sequences=True))
model.add(LSTM(units=32))
model.add(Dense(n_features))
model.compile(optimizer='Adamax', loss='mse')

# Train the model
model.fit(X_train, y_train, epochs=150, batch_size=64, validation_data=(X_test, y_test))

# Make predictions on the test data
y_pred = model.predict(X_test)

# Rescale the predicted and actual prices to their original range
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test)

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test, y_pred)))

"""### Predicting Potato Prices"""

y_pred_col1 = y_pred[:,0]
y_test_col1 = y_test[:,0]
df_pred = pd.DataFrame({'Predicted': y_pred_col1, 'Original': y_test_col1})
results_df1 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 0], 'Predicted': y_pred[:, 0]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col1, y_pred_col1))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col1, y_pred_col1)))

# Plot the predicted and actual values
plt.plot(results_df1['Date'], results_df1['Original'], label='Original')
plt.plot(results_df1['Date'], results_df1['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[0]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Onion Prices"""

y_pred_col2 = y_pred[:,1]
y_test_col2 = y_test[:,1]
df_pred = pd.DataFrame({'Predicted': y_pred_col2, 'Original': y_test_col2})
results_df2 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 1], 'Predicted': y_pred[:, 1]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col2, y_pred_col2))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col2, y_pred_col2)))

# Plot the predicted and actual values
plt.plot(results_df2['Date'], results_df2['Original'], label='Original')
plt.plot(results_df2['Date'], results_df2['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[1]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Peas Prices"""

y_pred_col3 = y_pred[:,2]
y_test_col3 = y_test[:,2]
df_pred = pd.DataFrame({'Predicted': y_pred_col3, 'Original': y_test_col3})
results_df3 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 2], 'Predicted': y_pred[:, 2]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col3, y_pred_col3))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col3, y_pred_col3)))

# Plot the predicted and actual values
plt.plot(results_df3['Date'], results_df3['Original'], label='Original')
plt.plot(results_df3['Date'], results_df3['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[2]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Tomato Prices"""

y_pred_col4 = y_pred[:,3]
y_test_col4 = y_test[:,3]
df_pred = pd.DataFrame({'Predicted': y_pred_col4, 'Original': y_test_col4})
results_df4 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 3], 'Predicted': y_pred[:, 3]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col4, y_pred_col4))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col4, y_pred_col4)))

# Plot the predicted and actual values
plt.plot(results_df4['Date'], results_df4['Original'], label='Original')
plt.plot(results_df4['Date'], results_df4['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[3]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Carrot Prices"""

y_pred_col5 = y_pred[:,4]
y_test_col5 = y_test[:,4]
df_pred = pd.DataFrame({'Predicted': y_pred_col5, 'Original': y_test_col5})
results_df5 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 4], 'Predicted': y_pred[:, 4]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col5, y_pred_col5))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col5, y_pred_col5)))

# Plot the predicted and actual values
plt.plot(results_df5['Date'], results_df5['Original'], label='Original')
plt.plot(results_df5['Date'], results_df5['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[4]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Garlic Prices"""

y_pred_col6 = y_pred[:,5]
y_test_col6 = y_test[:,5]
df_pred = pd.DataFrame({'Predicted': y_pred_col5, 'Original': y_test_col5})
results_df6 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 5], 'Predicted': y_pred[:, 5]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col6, y_pred_col6))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col6, y_pred_col6)))

# Plot the results
plt.plot(results_df6['Date'], results_df6['Original'], label='Original')
plt.plot(results_df6['Date'], results_df6['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[5]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Ginger Prices"""

y_pred_col7 = y_pred[:,6]
y_test_col7 = y_test[:,6]
df_pred = pd.DataFrame({'Predicted': y_pred_col7, 'Original': y_test_col7})
results_df7 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 6], 'Predicted': y_pred[:, 6]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col7, y_pred_col7))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col7, y_pred_col7)))

# Plot the results
plt.plot(results_df7['Date'], results_df7['Original'], label='Original')
plt.plot(results_df7['Date'], results_df7['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[6]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

"""### Predicting Green Chilli Prices"""

y_pred_col8 = y_pred[:,7]
y_test_col8 = y_test[:,7]
df_pred = pd.DataFrame({'Predicted': y_pred_col8, 'Original': y_test_col8})
results_df8 = pd.DataFrame({'Date': df.index[train_size+time_steps:], 'Original': y_test[:, 7], 'Predicted': y_pred[:, 7]})

# Calculate mean absolute error (MAE)
print("MAE: ",mean_absolute_error(y_test_col8, y_pred_col8))

# Calculate root mean squared error (RMSE)
print("RMSE: ",math.sqrt(mean_squared_error(y_test_col8, y_pred_col8)))

# Plot the results
plt.plot(results_df8['Date'], results_df8['Original'], label='Original')
plt.plot(results_df8['Date'], results_df8['Predicted'], label='Predicted')
plt.title(f"Actual vs Predicted Prices for {df.columns[7]}")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

# Plot the results
plt.plot(date,y_pred_potato, label='SARIMA')
plt.plot(results_df1['Date'], results_df1['Original'], label='Original')
plt.plot(results_df1['Date'], results_df1['Predicted'], label='LSTM')
plt.title("Predicted Potato Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_onion, label='SARIMA')
plt.plot(results_df2['Date'], results_df2['Original'], label='Original')
plt.plot(results_df2['Date'], results_df2['Predicted'], label='LSTM')
plt.title("Predicted Onion Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_peas, label='SARIMA')
plt.plot(results_df3['Date'], results_df3['Original'], label='Original')
plt.plot(results_df3['Date'], results_df3['Predicted'], label='LSTM')
plt.title("Predicted Peas Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.xticks(rotation=45)
plt.show()

# Plot the results
plt.plot(date ,y_pred_tomato, label='SARIMA')
plt.plot(results_df4['Date'], results_df4['Predicted'], label='LSTM')
plt.plot(results_df4['Date'], results_df4['Original'], label='Original')
plt.title("Predicted Tomato Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_carrot, label='SARIMA')
plt.plot(results_df5['Date'], results_df5['Predicted'], label='LSTM')
plt.plot(results_df5['Date'], results_df5['Original'], label='Original')
plt.title("Predicted Carrot Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_garlic, label='SARIMA')
plt.plot(results_df6['Date'], results_df6['Predicted'], label='LSTM')
plt.plot(results_df6['Date'], results_df6['Original'], label='Original')
plt.title("Predicted Garlic Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_ginger, label='SARIMA')
plt.plot(results_df7['Date'], results_df7['Predicted'], label='LSTM')
plt.plot(results_df7['Date'], results_df7['Original'], label='Original')
plt.title("Predicted Ginger Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Plot the results
plt.plot(date ,y_pred_chili, label='SARIMA')
plt.plot(results_df8['Date'], results_df8['Original'], label='Original')
plt.plot(results_df8['Date'], results_df8['Predicted'], label='LSTM')
plt.title("Predicted Green Chili Prices by SARIMA vs LSTM")
plt.xlabel('Time')
plt.ylabel('Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

